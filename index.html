<!DOCTYPE html>
<html>
<head>
  <link href="http://mafintosh.com/rss.xml" rel="alternate" type="application/rss+xml" title="@mafintosh blogs about technology" />
  <title>@mafintosh blogs about technology</title>
  <style>
    html, body {
      padding: 0;
      margin: 0;
      font-family: Helvetica neue;
      line-height: 28px;
      font-size: 16px;
    }

    body {
      padding-bottom: 50px;
    }

    pre, code {
      line-height: 20px;
      font-family: Menlo, Monospace !important;
    }

    .decl {
      color: #a71d5d;
    }
    .call {
      color: #795da3;
    }
    .string {
      color: #183691;
    }
    .const {
      color: #0086b3;
    }
    .comment {
      color: #969896;
    }

    pre {
      padding: 20px;
      margin: 25px 0;
    }

    h1 {
      margin: 40px 0;
      font-size: 40px;
    }

    a {
      color: #0086b3;
      text-decoration: none;
    }

    header {
      padding: 20px;
      font-size: 16px;
      color: #969896;
    }

    pre {
      background-color: #F7F7F7;
      font-size: 14px;
    }

    #post {
      max-width: 800px;
      padding: 0 20px;
      margin: auto;
    }

    .date {
      font-size: 14px;
    }

    .title {
      margin-top: 30px;
      margin-bottom: 30px;
    }

    .title h1 {
      margin-bottom: 20px;
    }

    a:hover {
      text-decoration: underline;
    }

  </style>
</head>
<body>
<div id="main">
  <header>
    Mathias' thoughts on technology and all things Javascript<span style="float: right">@mafintosh on <a href="https://github.com/mafintosh">github</a> and <a href="https://twitter.com/mafintosh">twitter</a></span>
  </header>
  <div id="content">
    <div id="post">
      <div class="title">
        <h1 id="learning-javascript">Pragmatic Modularity</h1>
        <div class="date"><a href="/pragmatic-modularity.html">July 2016, Mathias Buus</a></div>
      </div>
      <div><p>In my opinion the best feature in <a href="https://nodejs.org/">Node.js</a> is the global <a href="https://nodejs.org/api/modules.html#modules_modules"><code>require</code></a> function.
Why is <code>require</code> great? It is the function that allows you to load in external modules not provided by node core. Not only is this a good feature by itself, but the way <code>require</code> loads modules makes Node.js the most module friendly development platform out there today.</p>
<p><code>require</code> works in a very straight forward way.</p>
<ol>
<li><code>require(&#39;./{name}&#39;)</code> will load a module relative to the file you are currently writing,</li>
<li><code>require(&#39;/{absolute-name}&#39;)</code> will load a module from an absolute path,</li>
<li><code>require(&#39;{module-name}&#39;)</code> will load a module stored in a node_modules folder.</li>
</ol>
<p>The way Node.js loads modules from the node_modules folder is incredibly smart. Let&#39;s say you do <code>require(&#39;request&#39;)</code> in a file stored in <code>/foo/bar/baz</code>.
What node will do is look for <code>request</code> in the following folders:</p>
<ol>
<li><code>/foo/bar/baz/node_modules/request</code></li>
<li><code>/foo/bar/node_modules/request</code></li>
<li><code>/foo/node_modules/request</code></li>
<li><code>/node_modules/request</code></li>
</ol>
<p>The first folder that contains <code>request</code> is the one node will return. Why is this important? It allows us to use multiple versions of <code>request</code> trivially. We can simply nest them inside multiple node_modules folders. Here is an example. Let&#39;s say my program has two files <code>foo.js</code> and <code>bar.js</code> that both wanna require request but different versions of it. We can easily do this now by structuring our program like this</p>
<pre><code>./foo.js
./node_modules/request &lt;-- version 1
./a-folder/bar.js
./a-folder/node_modules/request &lt;-- version 2
</code></pre><p>Now if <code>foo.js</code> does <code>require(&#39;request&#39;)</code> it will load version 1 and if <code>bar.js</code> does <code>require(&#39;request&#39;)</code> it will load version 2.
As an added bonus <code>foo.js</code> can still require <code>bar.js</code> by doing <code>require(&#39;./a-folder/bar.js&#39;)</code>.</p>
<p>The <code>require</code> function is also a great example of decoupling in practice (we&#39;ll get back to this later). It was added to node before <a href="https://www.npmjs.com/"><code>npm</code></a>, the node package manager, was created.
This meant that external developers could create third party package managers that all could install multiple versions of the same module without node needing to know that this was happening. Node was just reading files from a file system. There was a time we had multiple package managers in node all competing to be &quot;The One True Package Manager&quot;.</p>
<p>With npm came an explosion in the amount of packages available for node. Over 300,000 different packages can now be downloaded through npm.</p>
<h2 id="writing-great-modules">Writing great modules</h2>
<p>So Node.js is great for requiring modules and npm is great is distributing them. This begs the question: what is a good module? I&#39;ve personally written more than 400 modules. Some good, some bad, some truly terrible. These are some of things I&#39;ve learned writing them.</p>
<h3 id="keep-it-simple">Keep it simple</h3>
<p>This one you probably knew already. Try to keep things as simple as possible. Don&#39;t introduce new abstractions unless you really have to. Good modules just export a single function that does one thing and one thing only.</p>
<p>If you have a hard time explaining what your module does when writing the README it&#39;s probably too complicated and should be split into more modules.</p>
<h3 id="lower-level-is-better-than-higher-level">Lower level is better than higher level</h3>
<p>When designing an API for a new module you have to make a lot of decisions. You have to put yourself in the place of the users of the module and think about the different ways they&#39;ll wanna use your code. When your users have different use cases this means you&#39;ll have to make trade-offs in your API. This can be surprisingly tricky and I often see friends getting stuck trying to publish their new modules because of this.</p>
<p>The solution to this problem is to make your API more low level, meaning that you&#39;ll expose less abstractions and require users to call more functions to solve their use cases. In return your API will be more stable and much less likely to change dramatically over time.</p>
<p>An example of this pattern could be a module I wrote a while ago called <a href="https://github.com/mafintosh/multicast-dns">multicast-dns</a>. I started out wanting to make a 100% JavaScript implementation of a service discovery protocol used by <a href="https://en.wikipedia.org/wiki/Bonjour_(software">Bonjour</a>)/<a href="https://en.wikipedia.org/wiki/Zero-configuration_networking">ZeroConf</a> (the protocol your computer uses to find your printer). All the existing implementations (that <code>bind</code>ed to native code) used a lot of abstractions in their APIs, such as a ServiceBrowser that would emit events every time a new service would be discovered on the network. The high level APIs required a lot of state management and retry configuration, and was in general hard to implement. The solution for me was to rethink the problem and come up with the minimal abstraction possible to solve the core problem.</p>
<p>The final API ended up consisting of 2 low level methods and 2 low level events. One pair for sending/receiving a query looking for a service and another pair for answering a query (using the standard protocol underneath). Each method&#39;s arguments map very closely to what is being sent over the wire and the module has very little state. Higher level things like retries are left up to the user of the module.</p>
<pre><code class="lang-js">var mdns = require(&#39;multicast-dns&#39;)()

mdns.on(&#39;response&#39;, function(response) {
  console.log(&#39;got a response packet:&#39;, response)
})

mdns.on(&#39;query&#39;, function(query) {
  console.log(&#39;got a query packet:&#39;, query)
})

// lets query for an A record for &#39;brunhilde.local&#39;
mdns.query({
  questions:[{
    name: &#39;brunhilde.local&#39;,
    type: &#39;A&#39;
  }]
})
</code></pre>
<p>The result was a lightweight (~100 LoC) and easy to explain module that has a very stable interface.</p>
<p>An added benefit is that you can always turn a lower level module into a higher level one to make some common use cases simpler. My friend <a href="https://github.com/watson">@watson</a> actually published a high level implementation of the Bonjour protocol called <a href="https://github.com/watson/bonjour">bonjour</a> which uses my low level implementation to do the &quot;heavy lifting&quot;.</p>
<h3 id="avoid-peer-dependencies">Avoid peer dependencies</h3>
<p>What is a peer dependency? A peer dependency is when you have a function in your program that accepts an instance of some external prototype.
For example, if you write a module that sends back a cool favicon when a user requests <code>/favicon.ico</code> you might be tempted to make a function that accepts an <a href="https://expressjs.com/">expressjs</a> instance (express is a popular node.js web framework), attaches a route handler and returns the favicon.</p>
<pre><code class="lang-js">module.exports = awesomeFavicon

function awesomeFavicon (app) {
  app.get(&#39;/favicon.ico&#39;, function (req, res) {
    res.setHeader(&#39;Content-Type&#39;, &#39;image/x-icon&#39;)
    res.end(coolFavicon)
  })
}
</code></pre>
<p>What&#39;s the problem with this module? The problem is that since we are accepting an instance of external object we can no longer control the version of express this instance uses. What if express were to break the <code>.get</code> interface in a later version and release a new major bump? We don&#39;t have any way of enforcing that, which quickly turns maintaining this module into dependency hell.</p>
<p>We are also coupling express which makes our module less useful for a bunch of other use cases. What if a user wanted to use the plain http module? or <a href="http://hapijs.com/">hapi</a> or some other web framework?</p>
<p>What would be a better solution? Usually a peer dependency is a sign that your module is doing too much or coupling too many things. A fix usually evolves around rethinking the purpose of the module without the peer depencency and make the module do less things. For example we could change our module to simply expose a function that returns a favicon.</p>
<pre><code class="lang-js">module.exports = awesomeFavicon

// it is now up to the user to set up the route
function awesomeFavicon (req, res) {
  res.setHeader(&#39;Content-Type&#39;, &#39;image/x-icon&#39;)
  res.end(coolFavicon)
}
</code></pre>
<p>In this version the module does not have any peer dependencies except for an http request and response which comes from node core. In general peer dependencies from node core are more acceptable since they change less often (streams being a big exception here!).</p>
<p>You cannot always avoid peer dependencies but you should try to keep them at an absolute minimum and treat them as very expensive modularity wise.</p>
<h3 id="straight-forward-naming">Straight forward naming</h3>
<p>Choosing a good name for your module is always important. A good sign that your module has a clear one-purpose scope is that you can pick a self-explainatory name consisting of 2-3 words. It can be tempting to come up with funny or &quot;marketing&quot; sounding names but usually that just makes it harder for users to figure out what your module does.</p>
<p>Some examples of great names for small modules are:</p>
<ul>
<li><a href="https://github.com/maxogden/concat-stream">concat-stream</a> - a stream that concats all input into a single buffer,</li>
<li><a href="https://github.com/mikolalysenko/drag-and-drop-files">drag-and-drop-files</a> - a function that turns a div into a drop area,</li>
<li><a href="https://github.com/substack/insert-css">insert-css</a> - inserts css into the head tag of an html page.</li>
</ul>
<p>Once in a while you&#39;ll end up writing a module that has a bit broader scope than can be expressed in the module name. Recently I wrote a module that fits this pattern. The module is called <a href="https://github.com/mafintosh/hyperdrive">hyperdrive</a>. (Even though you make a bigger module you still want to keep the code base as lean as possible by factoring out various parts of the code base into independent modules.)</p>
<p>An anti-pattern to avoid when doing this is prefixing your dependency names with the parent module name. For example, hyperdrive relies on merkle trees internally and I wanted to factor out the generation of these into a separate module.
The easiest way of doing that would have been to create a new module and call it hyperdrive-merkle-tree-stream and have it generate a merkle tree specifically for what hyperdrive needed. However, by doing this, we introduce a coupling to hyperdrive and are making our new indedepent module much less usable for other projects. Instead the new module was simply called <a href="https://github.com/mafintosh/merkle-tree-stream">merkle-tree-stream</a> and has no coupling whatsoever to hyperdrive. When hyperdrive uses it, it passes in some configuration that makes it generate the merkle trees it needs.</p>
<p>The disadvantage is a bit more code in your parent module. The advantage is a highly decoupled module that will be much more stable over time and more usable for other developers.</p>
<h3 id="beware-of-i-o">Beware of I/O</h3>
<p>I/O stands for Input/Output and is a general term we use when a program is writing to disk, reading from the network or similar communications. I/O is hard to get right and introduces a hard coupling to your modules. Luckily functions that do I/O in node are easy to identify since node does async I/O. If a function takes a callback or returns a promise it is most likely doing some sort of I/O.</p>
<p>Why is I/O bad? Well it isn&#39;t really, except it will couple your module to a specific way of doing things. Here is an example. Let&#39;s say we wanted a module that gunzipped an http request. It might look something like this:</p>
<pre><code class="lang-js">var gunzipRequest = require(&#39;gunzip-request&#39;)

gunzipRequest(&#39;http://example.com&#39;, function (err, res) {
  // res is guaranteed to be gunzipped.
})
</code></pre>
<p>What if I want to gunzip something that isn&#39;t available over http? Then I cannot use this module since it couples http. It is easy to fix though. We can use streams to decouple I/O from the module.</p>
<pre><code class="lang-js">var gunzipStream = require(&#39;gunzip-stream&#39;)

doRequest(&#39;http://example.com&#39;, function (err, responseStream) {
  // unzippedStream is guaranteed to be gunzipped
  var unzippedStream = responseStream.pipe(gunzipRequest)
})
</code></pre>
<p>Now our module works for a lot more use cases! I wrote a module that will gunzip a stream if gzipped. It&#39;s called <a href="https://github.com/mafintosh/gunzip-maybe">gunzip-maybe</a>.</p>
<h2 id="epilogue">Epilogue</h2>
<p>Don&#39;t think of the above sections as absolute rules to what constitutes a good module. These are just patterns I&#39;ve noticed when writing my own. The easiest way to validate them is to start writing modules yourself. When publishing a new module you don&#39;t always know if it&#39;ll end up being good or bad. Most of the time you&#39;ll figure that out while using the module in different use cases. Don&#39;t look too much at github stars, or when the last commit was made. A small scoped module might not need updates because it is mostly done.</p>
<h2 id="related-links">Related links</h2>
<ul>
<li><a href="https://opbeat.com/community/posts/hypermodular-development-by-mathias-buus/">https://opbeat.com/community/posts/hypermodular-development-by-mathias-buus/</a> - A talk I did about modules.</li>
<li><a href="http://substack.net/finding_modules">http://substack.net/finding_modules</a> - Great blog post from @substack about finding modules.</li>
</ul>
</div>
    </div>
  </div>
</div>
</body>
</html>
